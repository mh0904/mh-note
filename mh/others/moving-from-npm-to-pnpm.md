# 为什么我放弃了 npm，全面拥抱 pnpm

前言：天下苦 npm 久矣
在前端开发的漫长岁月中，npm 几乎是每个开发者的“初恋”。然而，随着项目越做越大，代码库（Monorepo）越来越复杂，这位“初恋”逐渐显露出了它的短板：磁盘空间被疯狂蚕食、依赖安装慢如蜗牛，还有那让人摸不着头脑的 “幽灵依赖”。

直到我遇到了 pnpm。用过之后，我只想说一句话：“后悔没早点换。”

1. 磁盘空间的“救星”：基于内容寻址的存储
   如果你电脑里有 10 个项目，每个项目都用到了 React，在 npm 的世界里，你的磁盘上就会存在 10 份一模一样的 React 代码。

npm 的做法：简单粗暴的复制粘贴。

pnpm 的做法：它会将所有的依赖包存储在全局的一个 Content-addressable store（内容寻址存储）中。

核心原理：项目里的 node_modules 只是一个硬链接（Hard Link）。无论你有多少个项目，磁盘上同版本的包永远只存一份。这不仅极大地节省了 SSD 空间，也让 install 速度飞起。

2. 告别“依赖地狱”：严格的依赖管理
   npm 在 v3 版本后引入了扁平化结构。这虽然解决了嵌套层级过深的问题，却引入了幽灵依赖（Phantom dependencies）：

什么是幽灵依赖？ 你明明没有在 package.json 里声明 lodash，但因为你依赖的某个包用了它，你竟然可以在代码里直接 import \_ from 'lodash'。

pnpm 坚决说不。
它利用符号链接（Symbolic Link）构建了一套高度契合 Node.js 加载机制的目录结构。如果你没在 package.json 里显式声明，你就别想用它。这种**“严格性”**让项目的稳定性得到了质的飞跃，有效避免了由于底层依赖升级导致的线上崩溃。

3. 速度：快，是不需要解释的
   在日常开发中，切换分支后的 npm install 往往是去接咖啡的时间。而 pnpm 的安装过程分为三步：

解析（Resolution）

获取（Fetching）

链接（Linking）

得益于它不需要像 npm 那样频繁地读写磁盘文件，即使是在没有任何缓存的情况下，pnpm 的速度通常也是 npm 的 2-3 倍。

4. 完美契合 Monorepo（大仓库）
   现在的项目越来越多地采用 Monorepo 架构。npm 的 workspaces 虽然能用，但在处理子项目间的依赖隔离和共享时，体验极其笨重。

pnpm 天生自带对 Workspace 的顶级支持：

简单的 pnpm-workspace.yaml 配置。

极其方便的指令：pnpm -r exec <command>（递归执行所有子项目）。

过滤机制：只针对改动的项目进行安装和构建。

总结：是时候更新你的工具链了
虽然 npm 是行业的奠基者，但技术总是在迭代。pnpm 不仅仅是快，它代表的是一种更科学、更严谨、更高效的依赖管理哲学。

如果你还在忍受 node_modules 动辄几个 GB 的体积，或者在为离奇的依赖报错而头疼，那么请立即尝试：

Bash

npm install -g pnpm
pnpm install
一旦你体验过那种秒速安装的快感，你就再也回不去了。

互动环节
你会因为什么理由坚守 npm？或者你已经在使用 pnpm 过程中踩过哪些坑？欢迎在评论区一起交流！
