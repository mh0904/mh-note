## 为什么 vue2 中要求组件的模版只有一个根元素？

1. vue2 中采用的是虚拟 DOM 的更新方式，使用一个根节点可以让虚拟 DOM 的结构更加清晰，有助于 DOM 的更新及渲染。
2. vue3 中引入了多组件的方式，是因为在编译器层面做了些修改，引入了标记片段的编译机制。但是大多数场景下还是建议使用单个根组件的方式，因为可以带来更好的代码可维护性和性能的提升。

## 组件中 data 定义对象和函数区别？

1. 在一个单页面应用中有多个 vue 组件，每个 vue 组件中 data 是函数的作用是为了组件在实例化的过程中返回的是一个新的对象，这样其他 vue 组件实例中的 data 即使有相同的命名属性，也不会被串改，应该它们处于不同的作用域中。当然在如果只有一个根组件 data 可以是对象的，毕竟没有其他组件实例命名冲突的问题。

## 什么是 vue 中的单向数据流和双向数据流？

1. 单向数据流：父组件传递给子组件的数据只能单向流动。也就是说，当一个父组件将其数据传递给一个子组件时，子组件不能直接修改该数据，而是需要通过向父组件发送事件来请求更改该数据。这种单向数据流的方式可以确保应用程序的数据流向清晰明确，易于理解和维护。

2. 双向数据流：双向数据流指的是 vue 中使用 v-model 实现组件的双向数据绑定，常见的场景是在表单中使用，比如一个输入框中使用 v-model 绑定输入框的 value，这种绑定 v-model 会监听到输入框的变化，同时通知父组件修改状态，同样的父组件状态的改变也会同步修改 input 的值。

总结：单向数据流更容易理解和维护，同时避免了数据的不确定性，保证了数据的稳定。

## vue 中组件、插件和插槽的区别？

1. 每一个.vue 文件就是一个 vue 的组件，组件可以实现单个模块的功能，组件模式的优点是可以降低系统的耦合度，便于维护，快速定位问题，提高代码的可维护性。
2. 插件 vue 实现全局的功能。
   添加全局方法或者属性。如: vue-custom-element
   添加全局资源：指令/过滤器/过渡等。如 vue-touch
   通过全局混入来添加一些组件选项。如 vue-router
   添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。
   一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router
3. 插槽：插槽指的是开发者在开发组件的过程中将自定义的内容分发给不同的租金的方式。

## vue 初始化做了哪些事情？

合并组件选项，将组件配置项打平，存放到 vm.$options 选项上，减少原型链的查找
        对组件关系属性进行初始化，比如：$root、$parent、$children、$refs 等
        初始化自定义事件，比如：@myclick="clickHandle" 会被编译为this.$on('myClick', function clickHandle(){}) 和 this.$emit('myClick') 的形式
        初始化插槽（vm.$slots、vm.$scopedSlots）、定义_c方法，即createElement（h函数）、对$attrs 和\$listeners 属性进行响应式处理
执行 beforeCreate 生命周期函数
初始化 inject 选项，根据 inject 选项从祖代组件配置项中找到对应的 provide 选项，从而获取对应 key 中的值，得到 result[id]= val 形式的结果
初始化 state 数据，如：props、data、methods、watch、computed 等
处理 provide 选项，判断 provide 是不是函数，是函数就调用获取返回配置项，否则就直接使用 provide 选项
执行 created 生命周期函数

## 说说你对 vue 中双向数据绑定的理解?

双向数据绑定是通过数据劫持+发布订阅者的模式来实现的。数据劫持就是通过 object.defineProperty 中的 set 和 get 方法劫持数据属性的变化和修改。在数据发生变化的时候发布消息给订阅者，触发对象的监听回调渲染视图。实现数据的变化视图更新，视图变化数据更新。
第一步：实现数据代理需要对 object.defineProperty 进行封装，这里将它封装在 defineRactive 函数中，然后通过 Obsever 函数对其进行递归遍历，这样可以让其嵌套属性中子属性中都添加 getter 和 setter。
通过 compile 模板去解析指令，把每个模版中的变量解析成数据，初始化渲染视图，添加 Watcher 订阅者，把每个指令对应的节点绑定更新函数，数据变化，则更新视图。
Watcher 订阅者是 compile 模板和 Obsever 函数之间的桥梁。
watcher 的作用就是通过 getter 方法去收集依赖，将搜集的依赖放在 Dep 类中，当自身的依赖发生变化的时候调用 Dep 中 update 方法去触发 compile 中的回调。

## 说说 vue 中双向数据绑定的原理是什么？里面的关键点是什么？

vue 实现双向数据绑定的核心特性是允许视图和数据保持同步，这其中的依赖以下几个关键部分：
1、vue 中使用 Object.difineProperty 方法劫持各个属性的 getter 和 setter，当数据发生变化的时候发布消息给订阅者，触发相应的监听回调。
Object.defineProperty(data, 'prop', {  
 get() {  
 // 当读取 prop 时触发  
 },  
 set(newVal) {  
 // 当修改 prop 时触发  
 // 通知视图更新  
 }  
 }); 2.观察者 (Observer)
在 Vue 实例创建时，Vue 会遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter，这样 Vue 就能够追踪到每一个属性的变化，从而实现数据的变化驱动视图的变化。 3. 编译阶段 (Compile)
Vue 会将模板编译成虚拟 DOM 渲染函数。在编译过程中，会解析模板中的所有指令（如 v-model、v-bind 等），并为这些指令生成相应的数据绑定函数。 4. 依赖收集 (Dep)
每个属性都持有一个 Dep 对象，用于存储所有订阅了该属性的 Watcher 对象。当属性变化时，会通知其对应的 Dep 对象，Dep 对象会广播消息给所有订阅的 Watcher 对象，从而触发视图的更新。 5. Watcher
Watcher 对象用于观察数据的变化。在创建 Watcher 对象时，会传入一个回调函数（通常是更新视图的函数），并把这个回调函数添加到对应属性的 Dep 对象中，以便在数据变化时收到通知。 6. 虚拟 DOM (Virtual DOM)
Vue 使用虚拟 DOM 技术来减少真实 DOM 的操作，从而提高性能。当数据变化时，Vue 会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行对比，计算出最小的差异，然后将这些差异应用到真实 DOM 上。

      关键点：

      数据劫持：通过 Object.defineProperty 实现数据变化的监听。
      观察者：用于追踪数据的变化。
      依赖收集：建立数据与视图之间的依赖关系。
      Watcher：观察数据变化并触发视图更新。
      虚拟 DOM：减少真实 DOM 操作，提高性能。
      这种双向数据绑定机制使得 Vue 能够实现高效的响应式数据驱动视图更新。

## MVC，MVP 和 MVVM 的区别？

总结：
MVVM 是一种软件架构设计模式，它抽离了视图、数据和逻辑，并限定了 Model 和 View 只能通过 VM 进行通信，VM 订阅 Model 并在数据更新时候自动同步到视图。
MVC 将应用抽象为数据层（Model）、视图层（View）、逻辑层（controller），降低了项目耦合。但 MVC 并未限制数据流，Model 和 View 之间可以通信。
MVP 则限制了 Model 和 View 的交互都要通过 Presenter ，这样对 Model 和 View 解耦，提升项目维护性和模块复用性。
而 MVVM 是对 MVP 的 P 的改造，用 VM 替换 P ，将很多手动的数据=>视图的同步操作自动化，降低了代码复杂度，提升可维护性。

## Vue 的 diff 算法和虚拟 DOM 了解吗？

虚拟 dom 其实本身是一个 js 对象，在 vue 中通过 render 函数生成。
虚拟 DOM 之所以出现是由于传统的 api 或者 jQuery 去操作 DOM 的时代价是昂贵的，由于真实 DOM 的元素及其庞大，操作真实 DOM 的性能会很低。
虚拟 DOM 出现的优势是它抽象了原本的渲染过程，同时实现了跨平台的能力，不局限浏览器，ios，小程序等等。
当响应式数据发生改变的时候，render 函数会生成一个新的虚拟 DOM，然后去和旧的虚拟 DOM 进行比对，找到需要更改的节点，同时去更新真实的 DOM。
diff 算法的作用就是用于新旧虚拟 DOM 的比较，diff 算法会返回一个 patch 对象，这个对象中存储新旧虚拟 DOM 中改变的节点信息，最后通过纪录的信息去更改真实的 DOM。

## computed 和 watch 的实现原理？

computed 是 data 属性的一个订阅者，它在初始化时候被 data 属性收集依赖，当 computed 依赖的 data 属性改变后，标记该 computed 为 dirty，即数据更改过，当渲染使用到 computed 时候，再计算出 computed 的值从而得到最新的正确的值。

        watch：在组件初始化时候，遍历所有的watch，对每个watch创建订阅者，绑定依赖的data属性，当data属性改变后发布给订阅者，然后会执行相应地回调。

## vue 框架原理？

我们使用 Vue 开发应用，实际上是编写若干 Vue 组件，实现模板、data、生命周期钩子等，然后执行 new Vue()，将根组件挂载到指定的 DOM 节点上面，当我们编写的组件中生命周期钩子里面的或者在模板的元素事件中改变数据时候，视图会响应地更新。这样就实现了应用。
那么 Vue 是如何实现上面的效果的呢？
new Vue()之后，Vue 会从根组件开始，遍历整个组件树，对每个组件进行处理。
对于一个 Vue 组件，Vue 首先会进行模板编译，将模板编译为 render 函数，render 函数返回虚拟 DOM，如果遇到子组件，也对子组件做同样操作，最终形成一个虚拟 DOM 树。
Vue 会把虚拟 DOM 映射到真实 DOM 并渲染到指定节点上，这样就实现了视图的渲染。
Vue 在组件初始化时候还会设置数据为响应式，并将依赖于数据的渲染方法、computed、watch 收集起来。
当数据改变后，Vue 会根据初始化时候收集的依赖，更新视图，这时候我们就看到最新的界面了。

## 谈谈你有对 Vue 项目进行过哪些方面的优化？

对象层级不要过深，否则性能就会差（object.defineproperty 会进行遍历监听)
不需要响应式的数据不要放到 data 中（object.defineproperty 会对对象的每个属性开
启监听)
v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
大数据列表和表格性能优化-虚拟列表
大数据下拉组件性能优化-数据懒加载
防止内部泄漏，组件销毁后把全局变量和事件销毁
路由懒加载
第三方插件的按需引入（不要全部引入,不然打包体积过大)
适当采用 keep-alive 缓存组件
防抖、节流运用
服务端渲染 SSR
